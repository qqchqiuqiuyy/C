#include <stdio.h>

void recurse(int n)
{
	printf("递归深度%d，变量n所在地址为: %p\n", n, &n);	//%p格式符用于输出指针变量or地址 
	if (n < 4)
		recurse(n + 1);
	printf("递归深度%d，变量n所在地址为: %p\n", n, &n);
}

int main()
{
	recurse(1);
	return 0;
}

/*
	递归，就是函数自己调用自己。递归在某些情况下很有用处(如二叉搜索)，但如果递归没有设定可以终止递归的条件检测，
它会无限制进行递归调用，所以请确保你的递归函数有出口。 
	一般来说，递归的效率没有循环语句的高。	
	
	 
	理解递归，就从展开递归式开始。为方便理解，在括号内体现n的值，用箭头表示执行顺序(现实中C语言这样做不行)： 
	int main()
	{									  
	  Krecurse(1);→→	void recurse(int n (1))
	  ↓return 0;	 	{
	}			I	 	  ↓输出1;
				  I	  ↓if (n(1) < 4)	//true 
					I	  K→  recurse(n + 1 (2));→→	void recurse(int n (2))
					  I←←输出1; 	←←←				{
						} 				  I			  ↓输出2; 
											I			  ↓if (n(2) < 4)	//true
											  I		  K→	recurse(n + 1 (3));→→ void recurse(int n (3))
												I←←←	输出2;	←←←				{
														}				  I			  ↓输出3; 
																			I			  ↓if (n(3) < 4)	//true
																			  I		  K→	recurse(n + 1(4)); → void recurse(int n(4))
																				I←←←	输出3;	←←←←		  {
																						}					I			↓输出4
																											  I	    ↓if (n(4) < 4) //false									      
																												I		↓    ...
																												  I←←L输出4 
																													  }
	
	
	
	整个的执行顺序就是如该函数展开一样从上往下进行
	【注意】当函数递归至下一层的时候，该层内的变量n与上一层的变量n是不同的(地址不同)，因为两者实际上不在同一作用域上
			如果离开函数，在该函数内的所有变量都会消亡 
	随着递归的执行，这些变量n的值情况如下：
				递归深度1的变量n	递归深度2的变量n	递归深度3的变量n	递归深度4的变量n 
	第1级调用 			1				
	第2级调用			1					2
	第3级调用			1					2					3
	第4级调用			1					2					3					4
	第4级调用返回后		1					2					3
	第3级调用返回后		1					2
	第2级调用返回后		1
	第1级调用返回后	   							(全部结束)	 
	 
	
	
*/ 
