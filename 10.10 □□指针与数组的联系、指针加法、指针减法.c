#include <stdio.h>

int main()
{
	int nums[4] = {11, 12, 13, 14}, i = 0;
	int * ptr = nums;	//数组名是数组首元素的地址，等价于&nums[0]
	//将nums的地址赋给ptr后使得ptr也可以像数组nums一样用索引法访问
	printf("数组法         指针解引用法         指针算术访问地址\n"); 
	for (i = 0;i < 4;++i)
	{
		printf("ptr[%d] = %d", i, ptr[i]);				//等价于nums[i]、*(nums + i)和*(ptr + i) 
		printf("    *(ptr + %d) = %d", i, *(ptr + i));	//等价于nums[i]、*(nums + i)和*(ptr + i) 
		printf("    &ptr = %p\n", ptr + i);				//等价于&nums[i]
	}
	
	ptr = nums + 1;	//nums本质上属于int* 类型，所以可以使其偏移1位指向下一个元素
	printf("\nptr偏移1位后：\n");
	for (i = -1;i < 3;++i)
		printf("ptr[%d] = %d\n", i, ptr[i]);		//可见索引(下标)其实就是指针的偏移量	
		
	printf("\n&nums[2] - ptr = %d\n", &nums[2] - ptr);	//这里计算的是指针的偏移量 
	--ptr;	//将指针ptr回指nums[0]
	
	 
	 
	return 0;	
}

/*
	指针既可以指向一个变量，也可以指向一个数组
	而当你声明int nums[4];的时候，nums就自带为int* 类型了
	
	所以当你的指针赋上数组名(数组首元素地址)后，就可以像数组名那样使用索引法了
	int nums[4] = {1, 2, 3, 4};
	int * p = nums;
	p[2] = 5;	//对nums[2]修改为5 
	
	使用指针算术，我们可以很轻松的访问数组内的元素： 
	nums + i	//这里并不是将nums的地址值加上i个字节，而是根据nums的类型为int*，给地址值加上i * sizeof (int)个字节，
				//从而指向下一个元素的地址
	nums - i	//同样这里并不是将nums的地址值加上一个字节，而是根据nums的类型为int*，给地址值减去i * sizeof (int)个字节， 
				//从而指向上一个元素的地址
	
	//这里我们将i叫作指针的偏移量，比如nums + 3就是指针偏移3位，指向第4个元素
	//同样索引法也是根据中括号内的索引值来决定指针的偏移量，所以nums[0]就是*nums本身，nums[3]就是*(nums + 3)
	
	指针间的减法运算：
	在一个数组内，两个指针(地址)相减，得到的是指针的偏移量
	&nums[2] - &nums[0] 	//结果是2，而不是8 
	&nums[0] - &nums[2] 	//结果是-2，而不是-8 
	
	
	数组的内存模型：
	int nums[4] = {2,3,4,6};
	
	    *(nums+3)  *(nums+2)  *(nums+1)   *nums
		  nums[3]    nums[2]    nums[1]    nums[0] 
	--------------------------------------------------- 
	值	[    6    ][    4    ][    3    ][    2    ] 
	地址0x0000100C 0x00001008 0x00001004 0x00001000
	内存地址增长 <------------------------------------- 
	--------------------------------------------------- 
	     &nums[3]   &nums[2]   &nums[1]   &nums[0]
		  nums + 3   nums + 2   nums + 1   nums			
	
	注意！不要将指针指向未初始化的变量，可能导致你修改到程序数据或代码，导致程序崩溃。 
	
	
*/ 
