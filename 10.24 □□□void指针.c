#include <stdio.h>


int main()
{
	float num = 18.5;
	void * vp = &num;
	printf("%#x\n", *(int *) vp);	//vp先被强制转换成int指针，再对其解除引用。
	//同一片内存的二进制值，对不同的变量类型就有不同的解读
	
	/*
		额外知识：IEEE浮点数 
		float和int都是32位数据，但保存浮点数是以二进制科学计数法的形式来保存的，
		如：二进制数 * 2^n (二进制数的小数点左边只能有1位，如1.10、1.11101、1.0001等，n决定小数点右移n位) 
		如：18.5 转写成二进制科学计数法就是 1.00101 * 2^4
		32位二进制数划分为三个区域
		0         	00000000 	  0000000 00000000 00000000 
		符号位		指数位 				小数位 
		(0正1负)	将n加上127 		二进制数的小数部分 
		1位 		 8位 				23位 
	
	
	  18.5的二进制科学计数法是1.00101 * 2^4，因此符号位是0，指数位由4 + 127变成131，转成二进制10000011，
	  小数位是0010100 00000000 00000000，组合一起就是
	   01000001 10010100 00000000 00000000 (即0x41940000) 
	
	  但对int来说，0x41940000的值就是它本身 
	*/
	
	long long l = 0x0004000300020001;
	vp = &l;
	int i;
	printf("将vp转换成short指针访问l：\n");
	for (i = 0; i < 4; ++i)
		printf("vp[%d] = %d, 即 %#06x\n", i, ((short *)vp)[i], ((short *)vp)[i]);
		
	printf("将vp转换成int指针访问l： \n");
	for (i = 0; i < 2; ++i)
		printf("vp[%d] = %d, 即 %#010x\n", i, ((int*) vp)[i], ((int*) vp)[i]);
	/*
		分析内存
		long long l = 0x0004000300020001;	//long long 占8字节，64位 
		
		
	值    00000000    00000100     00000000    00000011    00000000    00000010    00000000    00000001    
	地址  0x00001007  0x00001006   0x00001005  0x00001004  0x00001003  0x00001002  0x00001001  0x00001000
	                       |                        |                       |                       |
			    		   |			     		|	 				    |					   vp	 
	                 (short*)vp+3              (short*)vp+2            (short*)vp+1             (short*) vp
	                                            (int *)vp+1                                      (int *) vp
	
	*/
	
	return 0;
}




/*
	void指针(void*)并不是指 空指针，而是一种泛用指针类型，它只保存地址值而不会去推断变量类型及元素个数 
	
	void不是一种变量类型，它只能用在函数返回值上，表示空 

	void指针的好处在于：任何指针类型都可以赋给void*，而且void*理论上可以赋给任何指针(保证void*管理的内存字节数比变量类型的大)
	即void指针可以指向任意类型数据，它只需知道所在地址是什么
	
	对void指针不能使用解除引用运算符*，也不能使用数组索引法(它不属于任何类型变量的指针所以无法索引访问)，更不能自递增、减，以及指针算术 
	
	对于int*指针，它不仅保存了地址，还将所管理的内存区域按每4字节划分。
	
	void指针的用途有：分配动态内存，然后创建动态数组；用于快速排序等 
	
*/
