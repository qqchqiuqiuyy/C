#include <stdio.h>

int main()
{
	int n = 3;
	int* p = &n; 
	printf("修改前： \n");
	printf(" n = %d\n", n);
	printf("&n = %p\n\n", &n);
	printf(" p = %p\n", p);
	printf("*p = %d\n", *p);
	printf("&p = %p\n", &p);
	
	*p = 5;
	printf("\n修改后：\n");
	printf(" n = %d\n", n);
	printf("&n = %p\n\n", &n);
	printf(" p = %p\n", p);
	printf("*p = %d\n", *p);
	printf("&p = %p\n", &p);
	
	return 0;
}


/*
	如果我们想要将变量所在的内存地址值保存起来，可以使用指针。
	 
	指针(pointer)是一种储存地址值的变量类型，可以用指针去访问它储存的地址值指向的内存位置。
	
	注意：所有的变量都是有专门储存的内存地址的，指针也不例外。 
	
	
	指针声明：
	int * p_i;	//int*即整型指针，p_i被声明为一个 ①指向 一个int变量(or数组)的指针，可以保存某一个int变量所在的地址值
	char * p_c; 	//char*即字符指针，p_c被声明为一个char变量(or数组)的指针，可以保存某一个char变量所在的地址值
	float *p_f, *p_g, p_h	//float*即浮点数指针，p_f和p_g被声明为一个float变量(or数组)的指针，
							//可以保存某一个float变量所在的地址值，但p_h是float型变量 
	//即在声明变量名处加上前缀(可空开) * 即代表这个变量类型为指针
	
	注意：不要将指针(如int *)类型的地址值赋给基本变量(如int)类型
		  同样不要将基本变量(如int)类型赋给指针(如int *)类型，这是一种很危险的做法，可能会访问到不该访问的内存地址
		 
	指针赋值：
    int a = 3;
	int * b = &a;	//a所在的地址值赋给指针b
	int * c = b;	//指针b保存的地址值赋给指针c
	int * d = a;	//不行！
	a = b;			//不行！   
	
	指针的 ②解除引用 运算符  *
	由于指针存有别的变量的地址，是一种间接引用，我们可以在指针加上前缀*解除引用，访问该地址所储存的值、甚至修改：
	int a = 3;
	int * b = &a;
	*b = 5;	 
	printf("%d",a);	//输出5
	
	所以指针可以通过获取变量地址值的手段来共享访问权、修改权。
	
	对于上述的a和b：
	a 和 *b 是等价的，都是变量的值
	&a 和 b 是等价的，都是变量所在的地址
	至于&b，则是指针所在的地址
	而对于*a，不能对变量解除引用
	
	*与&是相对的关系，一个从地址处获得值，一个是获得地址。他们优先级相同，而结合性是从右到左的 
	就好像对于int a;来说，a等价于*&a(即*(&a))，但不能写成&*a(因为不能对变量a解引用)。 
	
	关系图：
	int a = 3;
	int * b = &a;
	
		 *b      /------------------> [3]       a 
	      b [0x00001004]------->  0x00001004   &a 
         &b  0x00001000	
	
	 
		 
	输出指针变量需使用%p指针格式符	  
	
	注释   ①解除引用：指通过寻找所在地址去访问变量or数组 
	       ②指向： 指可以间接访问所指物，但还需要解除引用才能直接访问。 
	 
*/ 
