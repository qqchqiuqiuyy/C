#include <stdio.h>

int main()
{
	int a = 5;
	int nums[3] = {1, 2, 3};
	printf("%d\n",&a);	//曾经有同学犯这样的错误，实际上它打印的是a的地址值(十进制)
	printf("%p\n",&a);	//要打印变量地址值，使用%p指针格式符(十六进制)
	printf("%p\n",nums);	//通过与下行的比较，我们发现：【数组名其实是数组首元素的地址】 
	printf("%p\n",&nums[0]);
	printf("%p\n",&nums[1]);	//nums[1]所在地址与nums[0]所在地址相距4个字节 
	printf("%d\n",sizeof (&nums[0]));	//输出地址值所占用的字节数 
	return 0; 
}

/*
	使用取址运算符&可以对可取地址的变量or常变量调查它所在的内存地址 
	在32位编译器中，地址的显示是一个8位的16进制(也就是32位2进制，而64位编译器则是64位2进制)，
地址值如果作为一个变量来储存的话它将占用4个字节(在64位编译器将占用8字节)。 
	地址值的单位为一个字节，比如：
	&nums[0]  的地址值为  0x0028FEB0
	&nums[1]  的地址值为  0x0028FEB4
	它们之间相隔4个单位，即4个字节，正好也是一个int的差距
	
	注意：①&nums[1] - &nums[0]不等于4，以后我们将在指针算术中知道原因 
		  ②地址值虽然看起来是一个32位的整数，但是地址值和整数依然是两种不同的大类型
		   
	所以理论上，32位地址值理论上可以访问2^32Byte的内存，也就是4G的内存；而64位地址值
则可以访问 2^34G的内存。

	
	【重点】内存地址：
	我们曾经讲过在一个32位int中，低位到高位的顺序是从右到左的 
	00000000 00000000 00000000 00000000 
    |                                 | 
	第32位 	                          第1位 
    最高位                            最低位
	
	实际上，内存地址的增长也是从右到左的(硬件设定就是如此，而且这个概念十分重要)。
	对于int a = 0;的内存模型如下： 
	00000000    00000000    00000000    00000000
	<---------------从右到左增长------------------ 
地址0x00001003  0x00001002  0x00001001  0x00001000
                                           ↑ 
                                           &a
    注意：我们现在使用地址值0x00001000是为了方便大家观看，实际运行的时候变量被分配的内存地址是由系统随机分配的。 
	
	&a实际上指向的是a的最低位所在的字节 
    
	
	 
*/
