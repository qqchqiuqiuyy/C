#include <stdio.h>
int plus(int a, int b)
{
	if ((a & b) == 0)	//注意运算符优先级 
		return a ^ b;
	else
		return plus(a ^ b, (a & b) << 1);
}

int main()
{
	printf("%d", plus(7,5));
	return 0;
}


/*
	使用位运算符构造加法器 
	观察一组二进制运算：
	    (0 1 1 1)	7     
	+   (0 1 0 1)	5
	-------------
	    (1 1 0 0)  12
	
	首先，若只观察最低位加法的话，则有
	0 + 0 = 0     0 + 1 = 1
	1 + 0 = 1     1 + 1 = 0
	
	此时我们可以考虑使用异或运算符，因为：
	0 ^ 0 = 0     0 ^ 1 = 1
	1 ^ 0 = 1     1 ^ 1 = 0
	
	其次，当出现运算1 + 1 = 0的情况时，高位会进1  
		(0 1 1 1)   7
	^	(0 1 0 1)   5
	-----------------
	    (0 0 1 0)
    +   (1 0 1 0) 
    -----------------
        (1 1 0 0)  12
    
	 
	为保存进位信息，我们可以使用与运算符与左移运算符。因为进位是向前进1的
	    (1 0 1 0)   (a & b) << 1
	
	这样就有a + b = (a ^ b) + ((a & b) << 1)
	则需要写一个递归式，当且仅当a & b = 0，即没有进位的情况下才能结束。
	plus(a, b) = { plus(a ^ b, (a & b) << 1)  , a & b ≠ 0
	               a ^ b                      , a & b = 0 }
				    
		

*/
