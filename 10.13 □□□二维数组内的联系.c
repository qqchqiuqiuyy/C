#include <stdio.h>

int main()
{
	int n[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; //在这里能不用括号赋值是因为它们之间内存是连续的
	int i, j;
	printf("数组n的地址值如下：\n");
	for (i = 0;i < 3;++i)
	{
		for (j = 0;j < 4;++j)
			printf("&n[%d][%d]=%p ", i, j, &n[i][j]);
		putchar('\n'); 
	}
	
	printf("数组n的元素值如下： \n");
	for (i = 0;i < 3;++i)
	{
		for (j = 0;j < 4;++j)
			printf("n[%d][%d] = %2d  ", i, j, n[i][j]);
		putchar('\n');	
	}
	
	printf("数组n的三个数组首元素地址如下： \n");
	for (i = 0;i < 3;++i)
		printf("    n[%d] = %p  ", i, n[i]);
	putchar('\n');
	
	for (i = 0;i < 3;++i)
		printf("   n + %d = %p  ", i, n + i);
	putchar('\n');
	
	for (i = 0;i < 3;++i)
		printf("*(n + %d) = %p  ", i, *(n + i));
	printf("\n");
	
	printf("指针法访问数组n的每一个元素的地址如下： \n");
	for (i = 0;i < 3;++i)
	{
		for (j = 0;j < 4;++j)
			printf("*(n+%d)+%d= %p ", i, j, *(n + i) + j);
		putchar('\n');
	}
	
	printf("指针法访问数组n的每一个元素如下： \n");
	for (i = 0;i < 3;++i)
	{
		for (j = 0;j < 4;++j)
			printf("*(*(n+%d)+%d) = %2d ", i, j, *(*(n + i) + j));
		putchar('\n');
	}
	
	return 0; 
}

/*
	当你声明一个二维数组时，如int n[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} 
	那么数组名n就是一个二重指针，n也叫数组的数组，可以对其解除两次引用 
	n + i 等价于 &n[i] 或 &*(n + i) 是二重指针(int**)，指向第i + 1个数组   
	
	然后*(n + i) + j 等价于 n[i] + j 或 &n[i][j] 或 &*(*(n + i) + j) 解除了一重引用，是指针(int*)，指向第i + 1个数组中第j + 1个元素
	
	而*(*(n + i) + j) 等价于n[i][j] 由于解除了两层引用，是(int)，它将访问第i + 1个数组中第j + 1个元素。 
	 
	二维数组内存模型： 
	int n[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
	
	
	
	     | *(*(n+2)+3)  *(*(n+2)+2)  *(*(n+2)+1)   **(n+2)  || *(*(n+1)+3)  *(*(n+1)+2)  *(*(n+1)+1)   **(n+1) ||   *(*n+3)      *(*n+2)      *(*n+1)         **n   | 
	     |  n[2][3]      n[2][2]      n[2][1]      n[2][0]  ||  n[1][3]      n[1][2]      n[1][1]      n[1][0] ||   n[0][3]      n[0][2]      n[0][1]      n[0][0]  |
	值   |[    12   ]  [    11   ]  [    10   ]  [    9    ]  [    8    ]  [    7    ]  [    6    ]  [    5    ]  [    4    ]  [    3    ]  [    2    ]  [    1    ]     
	地址 |0x0000102C   0x00001028   0x00001024   0x00001020   0x0000101C   0x00001018   0x00001014   0x00001010   0x0000100C   0x00001008   0x00001004   0x00001000
         |     |            |            |             |    ||      |          |            |            |     ||      |            |            |            |     |
         |     |            |            |           n + 2  ||      |          |            |           n + 1  ||      |            |            |            n     |
		 |     |            |            |           &n[2]  ||      |          |            |          &n[1]   ||      |            |            |           &n[0]  |
		 |   n[2]+3      n[2]+2       n[2]+1         n[2]   ||    n[1]+3     n[1]+2       n[1]+1        n[1]   ||    n[0]+3       n[0]+2       n[0]+1        n[0]   |
		 |  *(n+2)+3    *(n+2)+2     *(n+2)+1      *(n + 2) ||   *(n+1)+3   *(n+1)+2     *(n+1)+1     *(n + 1) ||     *n+3         *n+2         *n+1         *n     |                                      	
	地址增长方向  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<             
	
	 
	首先观察程序运行结果，发现它们元素之间内存都是连续的，如n[0][3]的下一个元素就是n[1][0]
	 
	所以我们可以使用这种输入方法：
	int* p = *n;	//也可以是n[0]，两者都属于int* 
	for (i = 0;i < 3 * 4;++i)
	{
		scanf("%d",p);
		++p;
	}
	
	可以是
	for (i = 0;i < 3;++i)
		for (j = 0;j < 4;++j)
			scanf("%d",&n[i][j]);
			
	也可以是
	for (i = 0;i < 3;++i)
		for (j = 0;j < 4;++j)
			scanf("%d",*(n + i) + j);
			
	如果你想在函数里改变二重指针的地址值，请使用三重指针。。。。但我们不讲 
*/
