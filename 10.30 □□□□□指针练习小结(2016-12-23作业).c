/*

一、main()函数内有以下变量声明： 
    int a = 0, b[10] = {0}, c[2][3] = {0};
    int * d = b;
(1)声明一个指针指向变量a，对其修改为5   
    int * p1 = &a;
    *p1 = 5;

(2)声明一个指针指向数组b，对b[4]修改为5
    int * p2 = b;
    p2[4] = 5;	//*(p2 + 4) = 5;

(3)声明一个指针指向二维数组c的第二个数组，对其第二个元素修改为5
    int * p3 = c[1];
    p3[1] = 5;  //*(p3 + 1) = 5;

(4)声明一个 指向数组的指针 来指向二维数组c，对c[1][2]修改为5
    int (*p4)[3] = c;
    p4[1][2] = 5;
 // 必须确定数组第二维度大小，不能用int**来指向二维数组c，
//  c[1]的时候它不知道该跳多少个元素。  

(5) int * p5 = *c;  //或c[0]
    int i;
    for (i = 0;i < 6;++i)
        p5[i] = 1;
    /*或
    for (i = 0;i < 6;++i)
        *p5++ = 1;
    */
/*  对于n维的数组，可以经n-1次解除引用后赋给指针，因为数组
元素之间是连续的，c[0][2]与c[1][0]是相邻的，所以知道了数组
所有维度的大小就可以这么做  */
/* 
(6)  int ** p6 = &d;

二、对于void func()，要修改它的参数列表
(1)传递一个整数a的值
    void func(int val)
     
    func(a);

(2)传递变量a供函数修改
    void func(int * p)

    func(&a);

(3)传递数组b供函数修改 
    void func(int * arr, size_t n)
// 或void func(int arr[], size_t n)

    func(b, 10);
//传递一个数组的时候要同时传递一个数来确定元素个数

(4)传递二维数组c(确定列数为3)
    void func(int (*p)[3], size_t m)
//或void func(int p[][3], size_t m)

    func(c, 2);
/*传递一个第二维度固定的二维数组的时候，由于第一维度是可变的，那必须提供第一维度的大小（数组的个数） */
/* 
(5)传递二维数组c(行数列数不定)
    void func(int * p, size_t m, size_t n)
//或void func(int p[], size_t m, size_t n)
    func(*c, 2, 3);
/* 传递一个任意的二维数组，首先要传递第一维度和第二维度的大小，然后传递一个一重指针，虽然你不可以进行p[1][1]，但是你可以p[1*3+1]来替代。因为指针总是能知道int的大小来跳动
 */

/* 
(6)传递指针修改
    void func(int ** pp)

    func(&d); 


问题又来了，为什么这些函数都要额外加一个参数呢？我
void func(int arr[10])不行吗？

这是一个十分复杂的问题
①首先，在参数内填int arr[10]和int arr[]都是没有区别的，因为这并不能阻止在函数内访问arr[10]的嘛，又不会出现程序错误（因为C语言不阻止超界访问）；
②其次，在参数内提供第二个参数，可以作为循环的一个检测条件
③以后如果声明了动态数组的话，由于数组的元素个数是不确定的，而且你的这个函数要能适应各种情况（类似方程的通解），而不能只应对某种情况。
千言万语说不完= =就点到这里先



       

*/
